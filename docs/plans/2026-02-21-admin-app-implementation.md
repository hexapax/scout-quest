# Scout Quest Admin App — Implementation Plan

> **Status:** Partially implemented — core scaffolding complete. New collection models handled by `2026-02-21-combined-implementation.md` Task 15.

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Build an AdminJS-based web admin panel that provides CRUD visibility into Scout Quest MongoDB, read-only access to LibreChat MongoDB, and a dashboard with system health widgets and GCP log links.

**Architecture:** Express + AdminJS (v7, ESM-only) with Mongoose for dual MongoDB connections. Google OAuth via Passport for auth with email allowlist. Runs as a Docker container on the same VM, reverse-proxied by Caddy at `admin.hexapax.com`.

**Tech Stack:** Node.js, TypeScript, Express, AdminJS v7, @adminjs/express, @adminjs/mongoose, Mongoose, Passport (Google OAuth), Docker

**Design doc:** `docs/plans/2026-02-21-admin-app-design.md`

---

### Task 1: Project Scaffolding

**Files:**
- Create: `admin/package.json`
- Create: `admin/tsconfig.json`
- Create: `admin/.env.example`
- Create: `admin/.gitignore`

**Step 1: Create `admin/package.json`**

```json
{
  "name": "scout-quest-admin",
  "version": "1.0.0",
  "type": "module",
  "scripts": {
    "build": "tsc",
    "start": "node dist/index.js",
    "dev": "node --watch dist/index.js"
  },
  "dependencies": {
    "adminjs": "^7.8.0",
    "@adminjs/express": "^6.1.0",
    "@adminjs/mongoose": "^4.1.0",
    "express": "^4.21.0",
    "express-session": "^1.18.0",
    "connect-mongo": "^5.1.0",
    "mongoose": "^8.9.0",
    "passport": "^0.7.0",
    "passport-google-oauth20": "^2.0.0",
    "tslib": "^2.8.0",
    "express-formidable": "^1.2.0"
  },
  "devDependencies": {
    "@types/express": "^5.0.0",
    "@types/express-session": "^1.18.0",
    "@types/passport": "^1.0.0",
    "@types/passport-google-oauth20": "^2.0.0",
    "@types/node": "^20.0.0",
    "typescript": "^5.3.0"
  }
}
```

**Step 2: Create `admin/tsconfig.json`**

```json
{
  "compilerOptions": {
    "target": "ES2022",
    "module": "NodeNext",
    "moduleResolution": "NodeNext",
    "outDir": "dist",
    "rootDir": "src",
    "strict": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true,
    "resolveJsonModule": true,
    "declaration": true,
    "declarationMap": true,
    "sourceMap": true
  },
  "include": ["src/**/*"],
  "exclude": ["node_modules", "dist"]
}
```

**Step 3: Create `admin/.env.example`**

```bash
# ============================================
# Scout Quest Admin — Environment Variables
# ============================================
# Port for the admin panel
PORT=3082

# MongoDB connections
MONGO_URI_SCOUT=mongodb://scout-quest-mongodb:27017/scoutquest
MONGO_URI_LIBRECHAT=mongodb://ai-chat-mongodb:27017/LibreChat

# Google OAuth (same client as LibreChat instances)
GOOGLE_CLIENT_ID=<FILL_IN>
GOOGLE_CLIENT_SECRET=<FILL_IN>
GOOGLE_CALLBACK_URL=https://admin.hexapax.com/auth/google/callback

# Comma-separated list of emails allowed to access admin panel
ADMIN_EMAILS=jebramwell@gmail.com

# Session secret (auto-generated by deploy script, or set manually)
SESSION_SECRET=<GENERATE>

# Node environment
NODE_ENV=production
```

**Step 4: Create `admin/.gitignore`**

```
node_modules/
dist/
.env
.adminjs/
```

**Step 5: Install dependencies**

Run: `cd admin && npm install`
Expected: `node_modules/` directory created, `package-lock.json` generated

**Step 6: Verify TypeScript compiles (empty project)**

Run: `mkdir -p admin/src && echo 'console.log("hello")' > admin/src/index.ts && cd admin && npx tsc`
Expected: `dist/index.js` created

**Step 7: Commit**

```bash
git add admin/package.json admin/package-lock.json admin/tsconfig.json admin/.env.example admin/.gitignore
git commit -m "feat(admin): scaffold admin app with dependencies"
```

---

### Task 2: Mongoose Schemas — Scout Quest Collections

**Files:**
- Create: `admin/src/models/scout-quest/scout.ts`
- Create: `admin/src/models/scout-quest/requirement.ts`
- Create: `admin/src/models/scout-quest/chore-log.ts`
- Create: `admin/src/models/scout-quest/budget-entry.ts`
- Create: `admin/src/models/scout-quest/time-mgmt.ts`
- Create: `admin/src/models/scout-quest/loan-analysis.ts`
- Create: `admin/src/models/scout-quest/email-sent.ts`
- Create: `admin/src/models/scout-quest/reminder.ts`
- Create: `admin/src/models/scout-quest/user.ts`
- Create: `admin/src/models/scout-quest/audit-log.ts`
- Create: `admin/src/models/scout-quest/index.ts`

These schemas MUST match the document shapes defined in `mcp-servers/scout-quest/src/types.ts`. The MCP server uses the native MongoDB driver; these Mongoose schemas are independent but describe the same documents.

**Step 1: Create `admin/src/models/scout-quest/user.ts`**

```typescript
import mongoose, { Schema } from "mongoose";

const roleSchema = new Schema(
  {
    type: {
      type: String,
      enum: ["superuser", "admin", "adult_readonly", "parent", "scout", "test_scout"],
      required: true,
    },
    troop: String,
    scout_emails: [String],
    test_account: Boolean,
  },
  { _id: false }
);

const userSchema = new Schema(
  {
    email: { type: String, required: true, index: true },
    roles: { type: [roleSchema], default: [] },
  },
  { timestamps: { createdAt: "created_at", updatedAt: "updated_at" } }
);

export const User = mongoose.model("User", userSchema, "users");
```

**Step 2: Create `admin/src/models/scout-quest/scout.ts`**

```typescript
import mongoose, { Schema } from "mongoose";

const contactInfoSchema = new Schema(
  {
    name: { type: String, required: true },
    email: { type: String, required: true },
    preferred_contact: { type: String, enum: ["email", "phone", "text"] },
  },
  { _id: false }
);

const scoutSchema = new Schema(
  {
    email: { type: String, required: true, unique: true },
    name: { type: String, required: true },
    age: { type: Number, required: true },
    troop: { type: String, required: true },
    patrol: String,

    quest_state: {
      goal_item: String,
      goal_description: String,
      target_budget: Number,
      savings_capacity: Number,
      loan_path_active: { type: Boolean, default: false },
      quest_start_date: Date,
      current_savings: { type: Number, default: 0 },
      quest_status: {
        type: String,
        enum: ["setup", "active", "paused", "complete"],
        default: "setup",
      },
    },

    character: {
      base: { type: String, enum: ["guide", "pathfinder", "trailblazer"] },
      quest_overlay: String,
      tone_dial: Number,
      domain_intensity: Number,
      tone_min: Number,
      tone_max: Number,
      domain_min: Number,
      domain_max: Number,
      sm_notes: String,
      parent_notes: String,
      avoid: [String],
      calibration_review_enabled: Boolean,
      calibration_review_weeks: [Number],
      custom_overlay: {
        vocabulary: [String],
        analogies: [String],
        enthusiasm_triggers: [String],
      },
    },

    counselors: {
      personal_management: contactInfoSchema,
      family_life: contactInfoSchema,
    },

    unit_leaders: {
      scoutmaster: contactInfoSchema,
      asm: contactInfoSchema,
    },

    parent_guardian: contactInfoSchema,

    blue_card: {
      personal_management: {
        requested_date: Date,
        approved_date: Date,
        approved_by: String,
      },
      family_life: {
        requested_date: Date,
        approved_date: Date,
        approved_by: String,
      },
    },

    chore_list: [
      {
        id: String,
        name: String,
        frequency: String,
        earns_income: Boolean,
        income_amount: Number,
      },
    ],

    budget_projected: {
      income_sources: [{ name: String, weekly_amount: Number }],
      expense_categories: [{ name: String, weekly_amount: Number }],
      savings_target_weekly: Number,
    },
  },
  { timestamps: { createdAt: "created_at", updatedAt: "updated_at" } }
);

export const Scout = mongoose.model("Scout", scoutSchema, "scouts");
```

**Step 3: Create `admin/src/models/scout-quest/requirement.ts`**

```typescript
import mongoose, { Schema } from "mongoose";

const requirementSchema = new Schema({
  scout_email: { type: String, required: true, index: true },
  req_id: { type: String, required: true },
  badge: {
    type: String,
    enum: ["personal_management", "family_life"],
    required: true,
  },
  status: {
    type: String,
    enum: [
      "not_started", "in_progress", "tracking", "blocked",
      "needs_approval", "ready_for_review", "submitted",
      "needs_revision", "signed_off", "completed_prior",
      "excluded", "offered",
    ],
    required: true,
  },
  quest_driven: { type: Boolean, default: false },
  interaction_mode: {
    type: String,
    enum: ["in_person", "video", "email", "digital_submission", "parent_verify"],
  },

  tracking_start_date: Date,
  tracking_duration: {
    days: Number,
    weeks: Number,
  },
  tracking_progress: Number,

  parent_approved: Boolean,
  counselor_approved: Boolean,

  documents: [
    {
      name: String,
      content: String,
      submitted_date: Date,
    },
  ],

  submitted_to_counselor_date: Date,
  counselor_feedback: String,
  signed_off_date: Date,
  signed_off_by: String,

  notes: String,
  updated_at: { type: Date, default: Date.now },
});

requirementSchema.index({ scout_email: 1, req_id: 1 }, { unique: true });

export const Requirement = mongoose.model("Requirement", requirementSchema, "requirements");
```

**Step 4: Create `admin/src/models/scout-quest/chore-log.ts`**

```typescript
import mongoose, { Schema } from "mongoose";

const choreLogSchema = new Schema({
  scout_email: { type: String, required: true, index: true },
  date: { type: Date, required: true },
  chores_completed: [String],
  income_earned: { type: Number, default: 0 },
  notes: String,
  created_at: { type: Date, default: Date.now },
});

export const ChoreLog = mongoose.model("ChoreLog", choreLogSchema, "chore_logs");
```

**Step 5: Create `admin/src/models/scout-quest/budget-entry.ts`**

```typescript
import mongoose, { Schema } from "mongoose";

const budgetEntrySchema = new Schema({
  scout_email: { type: String, required: true, index: true },
  week_number: { type: Number, required: true },
  week_start: { type: Date, required: true },
  income: [{ source: String, amount: Number }],
  expenses: [{ category: String, amount: Number, description: String }],
  savings_deposited: { type: Number, default: 0 },
  running_savings_total: { type: Number, default: 0 },
  notes: String,
  created_at: { type: Date, default: Date.now },
});

export const BudgetEntry = mongoose.model("BudgetEntry", budgetEntrySchema, "budget_entries");
```

**Step 6: Create `admin/src/models/scout-quest/time-mgmt.ts`**

```typescript
import mongoose, { Schema } from "mongoose";

const timeMgmtSchema = new Schema({
  scout_email: { type: String, required: true, index: true },
  exercise_week_start: Date,
  todo_list: [{ item: String, priority: Number, category: String }],
  weekly_schedule: [
    {
      day: String,
      fixed_activities: [{ time: String, activity: String }],
      planned_tasks: [{ time: String, todo_item: String }],
    },
  ],
  daily_diary: [
    {
      day: String,
      entries: [
        {
          scheduled_time: String,
          actual_time: String,
          task: String,
          completed: Boolean,
          notes: String,
        },
      ],
    },
  ],
  reflection: String,
});

export const TimeMgmt = mongoose.model("TimeMgmt", timeMgmtSchema, "time_mgmt");
```

**Step 7: Create `admin/src/models/scout-quest/loan-analysis.ts`**

```typescript
import mongoose, { Schema } from "mongoose";

const loanAnalysisSchema = new Schema({
  scout_email: { type: String, required: true, index: true },
  shortfall: Number,
  options_explored: [
    {
      option: String,
      details: String,
      total_cost: Number,
      timeline: String,
    },
  ],
  selected_option: String,
  parent_loan: {
    principal: Number,
    interest_rate: Number,
    term_weeks: Number,
    weekly_payment: Number,
    total_cost_with_interest: Number,
    proposal_document: String,
    parent_approved: Boolean,
    repayment_log: [{ week: Number, amount_paid: Number, remaining_balance: Number }],
  },
});

export const LoanAnalysis = mongoose.model("LoanAnalysis", loanAnalysisSchema, "loan_analysis");
```

**Step 8: Create `admin/src/models/scout-quest/email-sent.ts`**

```typescript
import mongoose, { Schema } from "mongoose";

const emailSentSchema = new Schema({
  scout_email: { type: String, required: true, index: true },
  date: { type: Date, required: true },
  to: { type: String, required: true },
  cc: [String],
  subject: { type: String, required: true },
  context: String,
});

export const EmailSent = mongoose.model("EmailSent", emailSentSchema, "emails_sent");
```

**Step 9: Create `admin/src/models/scout-quest/reminder.ts`**

```typescript
import mongoose, { Schema } from "mongoose";

const reminderSchema = new Schema({
  scout_email: { type: String, required: true, index: true },
  type: {
    type: String,
    enum: ["chore", "deadline", "check_in", "diary", "budget_update"],
    required: true,
  },
  message: { type: String, required: true },
  schedule: String,
  last_triggered: Date,
  next_trigger: Date,
  active: { type: Boolean, default: true },
  created_at: { type: Date, default: Date.now },
});

export const Reminder = mongoose.model("Reminder", reminderSchema, "reminders");
```

**Step 10: Create `admin/src/models/scout-quest/audit-log.ts`**

```typescript
import mongoose, { Schema } from "mongoose";

const auditLogSchema = new Schema({
  admin_email: { type: String, required: true, index: true },
  action: { type: String, required: true, enum: ["create", "update", "delete"] },
  resource: { type: String, required: true },
  record_id: { type: String, required: true },
  old_value: Schema.Types.Mixed,
  new_value: Schema.Types.Mixed,
  timestamp: { type: Date, default: Date.now, index: true },
});

export const AuditLog = mongoose.model("AuditLog", auditLogSchema, "admin_audit_log");
```

**Step 11: Create `admin/src/models/scout-quest/index.ts`**

```typescript
export { User } from "./user.js";
export { Scout } from "./scout.js";
export { Requirement } from "./requirement.js";
export { ChoreLog } from "./chore-log.js";
export { BudgetEntry } from "./budget-entry.js";
export { TimeMgmt } from "./time-mgmt.js";
export { LoanAnalysis } from "./loan-analysis.js";
export { EmailSent } from "./email-sent.js";
export { Reminder } from "./reminder.js";
export { AuditLog } from "./audit-log.js";
```

**Step 12: Verify TypeScript compiles**

Run: `cd admin && npx tsc --noEmit`
Expected: No errors

**Step 13: Commit**

```bash
git add admin/src/models/scout-quest/
git commit -m "feat(admin): add Mongoose schemas for Scout Quest collections"
```

---

### Task 3: Mongoose Schemas — LibreChat Collections (Read-Only)

**Files:**
- Create: `admin/src/models/librechat/conversation.ts`
- Create: `admin/src/models/librechat/message.ts`
- Create: `admin/src/models/librechat/user.ts`
- Create: `admin/src/models/librechat/index.ts`

LibreChat's MongoDB schema is defined by its upstream codebase. These schemas need to capture the fields we care about for observability. They connect to a separate Mongoose connection (the ai-chat MongoDB instance).

**Step 1: Create `admin/src/models/librechat/conversation.ts`**

LibreChat conversations store metadata about each chat session.

```typescript
import { Schema } from "mongoose";
import { libreChatDb } from "../connections.js";

const conversationSchema = new Schema(
  {
    conversationId: { type: String, index: true },
    title: String,
    user: { type: String, index: true },
    endpoint: String,
    model: String,
    chatGptLabel: String,
    promptPrefix: String,
    createdAt: Date,
    updatedAt: Date,
  },
  { collection: "conversations", strict: false }
);

// strict: false allows reading fields we haven't explicitly defined

export const Conversation = libreChatDb.model("Conversation", conversationSchema);
```

**Step 2: Create `admin/src/models/librechat/message.ts`**

```typescript
import { Schema } from "mongoose";
import { libreChatDb } from "../connections.js";

const messageSchema = new Schema(
  {
    messageId: { type: String, index: true },
    conversationId: { type: String, index: true },
    parentMessageId: String,
    sender: String,
    text: String,
    isCreatedByUser: Boolean,
    model: String,
    endpoint: String,
    user: String,
    createdAt: Date,
    updatedAt: Date,
  },
  { collection: "messages", strict: false }
);

export const Message = libreChatDb.model("Message", messageSchema);
```

**Step 3: Create `admin/src/models/librechat/user.ts`**

```typescript
import { Schema } from "mongoose";
import { libreChatDb } from "../connections.js";

const libreChatUserSchema = new Schema(
  {
    name: String,
    username: String,
    email: { type: String, index: true },
    avatar: String,
    provider: String,
    role: String,
    emailVerified: Boolean,
    createdAt: Date,
    updatedAt: Date,
  },
  { collection: "users", strict: false }
);

export const LibreChatUser = libreChatDb.model("LibreChatUser", libreChatUserSchema);
```

**Step 4: Create `admin/src/models/librechat/index.ts`**

```typescript
export { Conversation } from "./conversation.js";
export { Message } from "./message.js";
export { LibreChatUser } from "./user.js";
```

**Step 5: Verify TypeScript compiles (will fail until connections.ts exists — that's expected, created in Task 4)**

Note: These models depend on `connections.ts` which is created in Task 4. They will compile together.

**Step 6: Commit**

```bash
git add admin/src/models/librechat/
git commit -m "feat(admin): add Mongoose schemas for LibreChat collections (read-only)"
```

---

### Task 4: Database Connections Module

**Files:**
- Create: `admin/src/models/connections.ts`

AdminJS with Mongoose needs actual `mongoose.Connection` objects. We need two: one for Scout Quest data (read-write) and one for LibreChat data (read-only).

**Step 1: Create `admin/src/models/connections.ts`**

```typescript
import mongoose from "mongoose";

const MONGO_URI_SCOUT = process.env.MONGO_URI_SCOUT || "mongodb://localhost:27017/scoutquest";
const MONGO_URI_LIBRECHAT = process.env.MONGO_URI_LIBRECHAT || "mongodb://localhost:27017/LibreChat";

// Default connection for Scout Quest (read-write)
// AdminJS uses mongoose.model() which registers on the default connection
export async function connectScoutDb(): Promise<typeof mongoose> {
  return mongoose.connect(MONGO_URI_SCOUT);
}

// Separate connection for LibreChat (read-only in the admin UI)
export const libreChatDb = mongoose.createConnection(MONGO_URI_LIBRECHAT);

libreChatDb.on("connected", () => {
  console.log("Connected to LibreChat MongoDB");
});

libreChatDb.on("error", (err) => {
  console.error("LibreChat MongoDB connection error:", err);
});
```

**Step 2: Verify TypeScript compiles**

Run: `cd admin && npx tsc --noEmit`
Expected: No errors (all model imports now resolve)

**Step 3: Commit**

```bash
git add admin/src/models/connections.ts
git commit -m "feat(admin): add dual MongoDB connection module"
```

---

### Task 5: AdminJS Resource Configuration

**Files:**
- Create: `admin/src/resources/scout-quest.ts`
- Create: `admin/src/resources/librechat.ts`

Resource configs tell AdminJS which fields to show in list/edit views, which actions to allow, and any validation hooks.

**Step 1: Create `admin/src/resources/scout-quest.ts`**

```typescript
import type { ResourceWithOptions } from "adminjs";
import {
  User, Scout, Requirement, ChoreLog, BudgetEntry,
  TimeMgmt, LoanAnalysis, EmailSent, Reminder, AuditLog,
} from "../models/scout-quest/index.js";

// Valid state transitions from mcp-servers/scout-quest/src/constants.ts
const VALID_TRANSITIONS: Record<string, string[]> = {
  not_started: ["in_progress", "offered", "excluded", "completed_prior"],
  offered: ["in_progress", "not_started"],
  in_progress: ["tracking", "blocked", "ready_for_review", "needs_approval"],
  tracking: ["ready_for_review", "in_progress"],
  blocked: ["in_progress"],
  needs_approval: ["in_progress", "blocked"],
  ready_for_review: ["submitted", "in_progress"],
  submitted: ["signed_off", "needs_revision"],
  needs_revision: ["in_progress"],
  signed_off: [],
  completed_prior: [],
  excluded: ["in_progress"],
};

export const scoutQuestResources: ResourceWithOptions[] = [
  {
    resource: Scout,
    options: {
      navigation: { name: "Scout Quest", icon: "Compass" },
      listProperties: ["name", "email", "troop", "quest_state.quest_status", "quest_state.current_savings", "updated_at"],
      showProperties: [
        "name", "email", "age", "troop", "patrol",
        "quest_state", "character", "counselors", "unit_leaders",
        "parent_guardian", "blue_card", "chore_list", "budget_projected",
        "created_at", "updated_at",
      ],
    },
  },
  {
    resource: Requirement,
    options: {
      navigation: { name: "Scout Quest", icon: "Compass" },
      listProperties: ["scout_email", "req_id", "badge", "status", "updated_at"],
      filterProperties: ["scout_email", "badge", "status", "quest_driven"],
      actions: {
        edit: {
          before: async (request) => {
            // Validate status transitions
            if (request.payload?.status && request.record?.params?.status) {
              const oldStatus = request.record.params.status;
              const newStatus = request.payload.status;
              const allowed = VALID_TRANSITIONS[oldStatus] || [];
              if (oldStatus !== newStatus && !allowed.includes(newStatus)) {
                throw new Error(
                  `Invalid status transition: ${oldStatus} → ${newStatus}. Allowed: ${allowed.join(", ") || "none (terminal state)"}`
                );
              }
            }
            return request;
          },
        },
      },
    },
  },
  {
    resource: ChoreLog,
    options: {
      navigation: { name: "Scout Quest", icon: "Compass" },
      listProperties: ["scout_email", "date", "chores_completed", "income_earned", "created_at"],
      filterProperties: ["scout_email", "date"],
      actions: {
        delete: { isAccessible: false }, // Financial records — no deletion
      },
    },
  },
  {
    resource: BudgetEntry,
    options: {
      navigation: { name: "Scout Quest", icon: "Compass" },
      listProperties: ["scout_email", "week_number", "week_start", "savings_deposited", "running_savings_total"],
      filterProperties: ["scout_email", "week_number"],
      actions: {
        delete: { isAccessible: false }, // Financial records — no deletion
      },
    },
  },
  {
    resource: TimeMgmt,
    options: {
      navigation: { name: "Scout Quest", icon: "Compass" },
      listProperties: ["scout_email", "exercise_week_start"],
    },
  },
  {
    resource: LoanAnalysis,
    options: {
      navigation: { name: "Scout Quest", icon: "Compass" },
      listProperties: ["scout_email", "shortfall", "selected_option"],
    },
  },
  {
    resource: EmailSent,
    options: {
      navigation: { name: "Scout Quest", icon: "Compass" },
      listProperties: ["scout_email", "date", "to", "subject"],
      actions: {
        edit: { isAccessible: false },   // Audit trail — read-only
        delete: { isAccessible: false },
        new: { isAccessible: false },
      },
    },
  },
  {
    resource: Reminder,
    options: {
      navigation: { name: "Scout Quest", icon: "Compass" },
      listProperties: ["scout_email", "type", "message", "active", "next_trigger"],
      filterProperties: ["scout_email", "type", "active"],
    },
  },
  {
    resource: User,
    options: {
      navigation: { name: "Scout Quest", icon: "Compass" },
      listProperties: ["email", "roles", "created_at"],
    },
  },
  {
    resource: AuditLog,
    options: {
      navigation: { name: "System", icon: "Settings" },
      listProperties: ["admin_email", "action", "resource", "record_id", "timestamp"],
      actions: {
        edit: { isAccessible: false },
        delete: { isAccessible: false },
        new: { isAccessible: false },
      },
    },
  },
];
```

**Step 2: Create `admin/src/resources/librechat.ts`**

```typescript
import type { ResourceWithOptions } from "adminjs";
import { Conversation, Message, LibreChatUser } from "../models/librechat/index.js";

// All LibreChat resources are read-only
const readOnly = {
  edit: { isAccessible: false },
  delete: { isAccessible: false },
  new: { isAccessible: false },
};

export const libreChatResources: ResourceWithOptions[] = [
  {
    resource: Conversation,
    options: {
      navigation: { name: "LibreChat", icon: "MessageCircle" },
      listProperties: ["title", "user", "endpoint", "model", "createdAt"],
      filterProperties: ["user", "endpoint", "model"],
      actions: readOnly,
    },
  },
  {
    resource: Message,
    options: {
      navigation: { name: "LibreChat", icon: "MessageCircle" },
      listProperties: ["conversationId", "sender", "model", "isCreatedByUser", "createdAt"],
      filterProperties: ["conversationId", "sender", "model", "isCreatedByUser"],
      showProperties: ["messageId", "conversationId", "sender", "text", "model", "endpoint", "isCreatedByUser", "createdAt"],
      actions: readOnly,
    },
  },
  {
    resource: LibreChatUser,
    options: {
      navigation: { name: "LibreChat", icon: "MessageCircle" },
      listProperties: ["name", "email", "provider", "role", "createdAt"],
      actions: readOnly,
    },
  },
];
```

**Step 3: Verify TypeScript compiles**

Run: `cd admin && npx tsc --noEmit`
Expected: No errors

**Step 4: Commit**

```bash
git add admin/src/resources/
git commit -m "feat(admin): add AdminJS resource configs for Scout Quest and LibreChat"
```

---

### Task 6: Authentication Module (Google OAuth + Email Allowlist)

**Files:**
- Create: `admin/src/auth.ts`

AdminJS's `buildAuthenticatedRouter` expects an `authenticate` function. We use Passport Google OAuth for the actual auth flow, but AdminJS handles sessions. We need a hybrid: use Google OAuth to verify identity, then check the email against an allowlist.

**Step 1: Create `admin/src/auth.ts`**

```typescript
import type { Request } from "express";

const ADMIN_EMAILS = (process.env.ADMIN_EMAILS || "")
  .split(",")
  .map((e) => e.trim().toLowerCase())
  .filter(Boolean);

if (ADMIN_EMAILS.length === 0) {
  console.warn("WARNING: ADMIN_EMAILS is empty — no one can log in");
}

/**
 * AdminJS authenticate function.
 * AdminJS v7 with @adminjs/express shows a login form by default.
 * We'll use a custom approach: redirect to Google OAuth,
 * then validate the returned email against the allowlist.
 */
export function isAllowedAdmin(email: string): boolean {
  return ADMIN_EMAILS.includes(email.toLowerCase());
}

/**
 * For AdminJS buildAuthenticatedRouter — called with form email/password.
 * Since we want OAuth, we'll handle auth differently in the main app.
 * This is a placeholder that always rejects form logins.
 */
export async function authenticate(email: string, password: string): Promise<Record<string, unknown> | null> {
  // Form-based login is not used — we use Google OAuth
  // Return null to reject form login attempts
  return null;
}
```

**Step 2: Commit**

```bash
git add admin/src/auth.ts
git commit -m "feat(admin): add Google OAuth authentication with email allowlist"
```

---

### Task 7: Main Application Entry Point

**Files:**
- Create: `admin/src/index.ts`

This wires everything together: Express, AdminJS, Mongoose connections, authentication, and starts the server.

**Step 1: Create `admin/src/index.ts`**

```typescript
import express from "express";
import session from "express-session";
import AdminJS from "adminjs";
import AdminJSExpress from "@adminjs/express";
import * as AdminJSMongoose from "@adminjs/mongoose";
import MongoStore from "connect-mongo";

import { connectScoutDb, libreChatDb } from "./models/connections.js";
import { scoutQuestResources } from "./resources/scout-quest.js";
import { libreChatResources } from "./resources/librechat.js";
import { authenticate } from "./auth.js";

// Register Mongoose adapter with AdminJS
AdminJS.registerAdapter({
  Resource: AdminJSMongoose.Resource,
  Database: AdminJSMongoose.Database,
});

const PORT = parseInt(process.env.PORT || "3082", 10);
const SESSION_SECRET = process.env.SESSION_SECRET || "change-me-in-production";
const MONGO_URI_SCOUT = process.env.MONGO_URI_SCOUT || "mongodb://localhost:27017/scoutquest";

async function start() {
  // Connect to both databases
  console.log("Connecting to Scout Quest MongoDB...");
  await connectScoutDb();
  console.log("Connected to Scout Quest MongoDB");

  // Wait for LibreChat connection
  await new Promise<void>((resolve, reject) => {
    if (libreChatDb.readyState === 1) {
      resolve();
      return;
    }
    libreChatDb.once("connected", resolve);
    libreChatDb.once("error", reject);
  });

  // Create AdminJS instance
  const admin = new AdminJS({
    resources: [...scoutQuestResources, ...libreChatResources],
    rootPath: "/",
    branding: {
      companyName: "Scout Quest Admin",
      logo: false,
      withMadeWithLove: false,
    },
    locale: {
      language: "en",
      translations: {
        en: {
          labels: {
            Scout: "Scouts",
            Requirement: "Requirements",
            ChoreLog: "Chore Logs",
            BudgetEntry: "Budget Entries",
            TimeMgmt: "Time Management",
            LoanAnalysis: "Loan Analysis",
            EmailSent: "Emails Sent",
            Reminder: "Reminders",
            User: "Users",
            AuditLog: "Audit Log",
            Conversation: "Conversations",
            Message: "Messages",
            LibreChatUser: "LibreChat Users",
          },
        },
      },
    },
  });

  const app = express();

  // Build authenticated router with session store
  const adminRouter = AdminJSExpress.buildAuthenticatedRouter(
    admin,
    {
      authenticate,
      cookieName: "scout-admin",
      cookiePassword: SESSION_SECRET,
    },
    null,
    {
      store: MongoStore.create({
        mongoUrl: MONGO_URI_SCOUT,
        collectionName: "admin_sessions",
      }),
      resave: false,
      saveUninitialized: false,
      secret: SESSION_SECRET,
      cookie: {
        httpOnly: true,
        secure: process.env.NODE_ENV === "production",
        maxAge: 24 * 60 * 60 * 1000, // 24 hours
      },
      name: "scout-admin",
    }
  );

  app.use(admin.options.rootPath, adminRouter);

  app.listen(PORT, () => {
    console.log(`Scout Quest Admin running at http://localhost:${PORT}`);
  });
}

start().catch((err) => {
  console.error("Failed to start admin app:", err);
  process.exit(1);
});
```

**Step 2: Verify TypeScript compiles**

Run: `cd admin && npx tsc --noEmit`
Expected: No errors

**Step 3: Commit**

```bash
git add admin/src/index.ts
git commit -m "feat(admin): add main entry point wiring AdminJS, Express, and MongoDB"
```

---

### Task 8: Docker Configuration

**Files:**
- Create: `admin/Dockerfile`
- Create: `config/admin/docker-compose.yml`
- Create: `config/admin/docker-compose.override.yml`
- Create: `config/admin/.env.example`

**Step 1: Create `admin/Dockerfile`**

Multi-stage build — builds TypeScript in a build stage, copies only dist + node_modules to production image.

```dockerfile
FROM node:20-slim AS builder
WORKDIR /app
COPY package.json package-lock.json ./
RUN npm ci
COPY tsconfig.json ./
COPY src/ src/
RUN npx tsc

FROM node:20-slim
WORKDIR /app
COPY --from=builder /app/dist dist/
COPY --from=builder /app/node_modules node_modules/
COPY --from=builder /app/package.json .
ENV NODE_ENV=production
EXPOSE 3082
CMD ["node", "dist/index.js"]
```

**Step 2: Create `config/admin/docker-compose.yml`**

```yaml
services:
  admin:
    build:
      context: ../../admin
      dockerfile: Dockerfile
    container_name: scout-admin
    restart: unless-stopped
    ports:
      - "3082:3082"
    env_file:
      - .env
    networks:
      - scout-shared

networks:
  scout-shared:
    external: true
    name: scout-shared
```

**Step 3: Create `config/admin/docker-compose.override.yml`**

```yaml
# Override file for admin — placeholder for future customizations
services:
  admin:
    container_name: scout-admin
```

**Step 4: Create `config/admin/.env.example`**

Copy from `admin/.env.example` (same file, placed in the config directory for the deploy script):

```bash
# ============================================
# Scout Quest Admin — Environment Variables
# ============================================
PORT=3082

# MongoDB connections (via scout-shared Docker network)
MONGO_URI_SCOUT=mongodb://scout-quest-mongodb:27017/scoutquest
MONGO_URI_LIBRECHAT=mongodb://ai-chat-mongodb:27017/LibreChat

# Google OAuth (same client as LibreChat instances)
GOOGLE_CLIENT_ID=<FILL_IN>
GOOGLE_CLIENT_SECRET=<FILL_IN>
GOOGLE_CALLBACK_URL=https://admin.hexapax.com/auth/google/callback

# Comma-separated list of admin emails
ADMIN_EMAILS=jebramwell@gmail.com

# Session secret
SESSION_SECRET=<GENERATE>

NODE_ENV=production
```

**Step 5: Verify Docker builds locally**

Run: `cd admin && docker build -t scout-admin-test .`
Expected: Image builds successfully

**Step 6: Commit**

```bash
git add admin/Dockerfile config/admin/
git commit -m "feat(admin): add Docker and deployment configuration"
```

---

### Task 9: Terraform — DNS Record for admin.hexapax.com

**Files:**
- Modify: `terraform/dns.tf` (add `admin` A record after the `scout_quest` record, ~line 90)
- Modify: `terraform/variables.tf` (add `domain_admin` variable)

**Step 1: Add variable to `terraform/variables.tf`**

After the `domain_scout` variable block, add:

```hcl
variable "domain_admin" {
  description = "Domain for the admin panel (e.g., admin.hexapax.com)"
  type        = string
  default     = "admin.hexapax.com"
}
```

**Step 2: Add DNS record to `terraform/dns.tf`**

After the `scout_quest` resource block (line 90), add:

```hcl
resource "google_dns_record_set" "admin" {
  project      = var.dns_project_id
  name         = "${var.domain_admin}."
  type         = "A"
  ttl          = 300
  managed_zone = data.google_dns_managed_zone.hexapax.name
  rrdatas      = [google_compute_address.static.address]
}
```

**Step 3: Verify Terraform plan**

Run: `cd terraform && terraform plan`
Expected: 1 resource to add (`google_dns_record_set.admin`)

**Step 4: Apply Terraform**

Run: `cd terraform && terraform apply`
Expected: DNS record created

**Step 5: Commit**

```bash
git add terraform/dns.tf terraform/variables.tf
git commit -m "infra: add admin.hexapax.com DNS record"
```

---

### Task 10: Update Caddy + Cloud-Init for Admin Reverse Proxy

**Files:**
- Modify: `terraform/cloud-init.yaml` (add admin proxy block to Caddyfile, ~line 44-52)

**Step 1: Update the Caddyfile template in `terraform/cloud-init.yaml`**

The Caddyfile section (lines 44-52) currently has two proxy blocks. Add a third:

```yaml
  - |
    cat > /etc/caddy/Caddyfile << 'EOF'
    ${domain_aichat} {
        reverse_proxy localhost:3080
    }

    ${domain_scout} {
        reverse_proxy localhost:3081
    }

    ${domain_admin} {
        reverse_proxy localhost:3082
    }
    EOF
```

Note: `${domain_admin}` is a Terraform template variable. Make sure it's passed through the `templatefile()` call in `main.tf` if that's how cloud-init is rendered.

**Step 2: Check how cloud-init template variables are passed**

Read `terraform/main.tf` to find the `templatefile()` call and add `domain_admin` to it.

**Step 3: Commit**

```bash
git add terraform/cloud-init.yaml terraform/main.tf
git commit -m "infra: add admin.hexapax.com reverse proxy to Caddy config"
```

---

### Task 11: Update Deploy Script for Admin Instance

**Files:**
- Modify: `deploy-config.sh`

The deploy script currently only deploys `ai-chat` and `scout-quest`. The admin app uses a different deployment pattern (Docker build, not LibreChat clone), so it needs its own deploy logic.

**Step 1: Add `admin` to the INSTANCES array — but with different handling**

The admin app doesn't use `librechat.yaml` or `docker-compose.override.yml` from LibreChat. It has its own `docker-compose.yml`. The deploy script needs to:

1. Pull `.env` from GCS for admin
2. Build the Docker image on the VM (or push a pre-built image)
3. Run `docker compose up -d` in the admin directory

Add a new function `deploy_admin()` to the deploy script that:
- Copies `.env` from GCS to VM at `/opt/scoutcoach/admin/.env`
- Copies the `config/admin/docker-compose.yml` to VM
- Copies the `admin/` source directory to VM
- Runs `docker compose build && docker compose up -d` on the VM

The specifics here depend on whether we want to build locally and push an image, or build on the VM. Building on the VM is simpler for now since we're already SSHing in.

**Step 2: Commit**

```bash
git add deploy-config.sh
git commit -m "feat: extend deploy script to support admin app"
```

---

### Task 12: Update Caddy on Live VM

Since the VM's Caddyfile was written by cloud-init at first boot, updating the Terraform cloud-init template won't change the running VM. The Caddyfile needs to be updated manually on the running VM.

**Step 1: SSH to VM and update Caddyfile**

```bash
gcloud compute ssh scout-coach-vm --zone=us-east4-b --command="
sudo tee /etc/caddy/Caddyfile > /dev/null << 'EOF'
ai-chat.hexapax.com {
    reverse_proxy localhost:3080
}

scout-quest.hexapax.com {
    reverse_proxy localhost:3081
}

admin.hexapax.com {
    reverse_proxy localhost:3082
}
EOF
sudo systemctl reload caddy
"
```

Expected: Caddy reloads with the new admin proxy rule. First HTTPS request to admin.hexapax.com will trigger Let's Encrypt cert issuance (~30s).

---

### Task 13: Build, Deploy, and Verify

**Step 1: Build admin Docker image locally and test**

```bash
cd admin && docker build -t scout-admin .
```

**Step 2: Push .env to GCS**

```bash
./deploy-config.sh push
```

**Step 3: Deploy admin app to VM**

This depends on the deploy script changes from Task 11. The admin app needs to be copied to the VM and built/started there.

**Step 4: Verify admin panel loads**

Open: `https://admin.hexapax.com`
Expected: AdminJS login page (or redirect to Google OAuth)

**Step 5: Verify data visibility**

After logging in:
1. Check "Scout Quest" navigation — should show all 9 collections
2. Check "LibreChat" navigation — should show Conversations, Messages, LibreChat Users (read-only)
3. Try editing a Scout record — should work
4. Try editing an EmailSent record — should be blocked (read-only)
5. Try editing a LibreChat Conversation — should be blocked (read-only)
6. Try an invalid requirement status transition — should show error

---

### Task 14: Update Documentation

**Files:**
- Modify: `docs/architecture.md` (add admin app to architecture diagram and service tables)
- Modify: `CLAUDE.md` (add admin app section to Key Directories and Common Commands)

**Step 1: Update `docs/architecture.md`**

Add admin app to:
- Architecture diagram (port 3082, admin.hexapax.com)
- Docker services table
- Docker networking section
- Feature mapping table

**Step 2: Update `CLAUDE.md`**

Add to Key Directories:
```
- `admin/` — Admin panel source (AdminJS + Express + Mongoose)
- `config/admin/` — Admin panel deployment config (docker-compose, .env)
```

**Step 3: Commit**

```bash
git add docs/architecture.md CLAUDE.md
git commit -m "docs: add admin app to architecture docs and CLAUDE.md"
```

---

## Task Dependencies

```
Task 1 (scaffold) → Task 2 (scout schemas) → Task 5 (resources)
                  → Task 3 (librechat schemas) → Task 5
                  → Task 4 (connections) → Task 5
Task 5 (resources) → Task 6 (auth) → Task 7 (entry point)
Task 7 (entry point) → Task 8 (docker)
Task 8 (docker) → Task 13 (deploy & verify)
Task 9 (terraform DNS) → Task 12 (update caddy) → Task 13
Task 10 (cloud-init) — can run in parallel with everything
Task 11 (deploy script) → Task 13
Task 14 (docs) — after Task 13 verified
```

## Notes for the Implementer

- **AdminJS v7 is ESM-only.** All imports must use `.js` extensions. `"type": "module"` in package.json.
- **Mongoose schemas match `mcp-servers/scout-quest/src/types.ts`.** If the MCP server adds fields, update admin schemas too.
- **LibreChat schemas use `strict: false`** to read fields we haven't explicitly defined. This prevents breakage if LibreChat adds fields upstream.
- **LibreChat models use `libreChatDb.model()`** (separate connection), while Scout Quest models use `mongoose.model()` (default connection). This is how AdminJS handles dual databases.
- **Auth is a known gap.** AdminJS's built-in auth uses email/password forms. Google OAuth integration may require a custom auth flow — either a custom login page that redirects to Google OAuth, or using Passport middleware before AdminJS routes. The `authenticate` function in Task 6 is a placeholder. Refine during implementation.
- **The deploy script (Task 11) needs design decisions** about local vs VM builds. Start simple: copy source to VM, build there with Docker multi-stage.
- **`terraform apply` for DNS (Task 9) can be done early** — the A record pointing to the VM IP is harmless before the app exists.
